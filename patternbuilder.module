<?php
/**
 * @file
 * Module for loading and parsing json schema files.
 */

// Constants.
define('PATTERNBUILDER_PROPERTY_PREFIX_TUPLE_ITEM', 'pb_tuple_item');
define('PATTERNBUILDER_PROPERTY_DELIMITER', '::');
define('PATTERNBUILDER_PROPERTY_MAP_RENDERED_NAME', 'pb_rendered');
define('PATTERNBUILDER_PROPERTY_MAP_ITEM_DELIMITER', ',');
define('PATTERNBUILDER_PROPERTY_MAP_VALUE_DELIMITER', '=');
define('PATTERNBUILDER_PROPERTY_MAP_CHAIN_DELIMITER', ':');

/**
 * Implements hook_hook_info().
 */
function patternbuilder_hook_info() {
  $base_info = array('group' => 'patternbuilder');

  return array(
    'patternbuilder_pattern_types' => $base_info,
    'patternbuilder_pattern_types_alter' => $base_info,
  );
}

/**
 * Implements hook_menu().
 */
function patternbuilder_menu() {
  $items = array();

  // Admin config page.
  $items['admin/config/content/patternbuilder'] = array(
    'title' => 'Pattern Builder',
    'description' => 'Settings for the patternbuilder module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('patternbuilder_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'patternbuilder.admin.inc',
    'weight' => -100,
  );

  return $items;
}

/**
 * Implements hook_libraries_info().
 */
function patternbuilder_libraries_info() {
  $libraries = array();
  $libraries['patternbuilder'] = array(
    // Only used in administrative UI of Libraries API.
    'title' => t('PatternBuilder'),
    'vendor url' => 'https://github.com/PatternBuilder/pattern-builder-lib-php',
    'download url' => 'https://github.com/PatternBuilder/pattern-builder-lib-php',
    'path' => 'vendor',
    'version' => 'v1.0.0',
    'files' => array(
      'php' => array(
        'autoload.php',
      ),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_views_api().
 */
function patternbuilder_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'patternbuilder') . '/views',
  );
}

/**
 * Invalidate all patternbuilder cache, forcing a rebuild on the next grab.
 */
function patternbuilder_invalidate_cache() {
  // Fully built schemas could reference a schema that has changed so all
  // cached schema objects must be purged.
  $controller = patternbuilder_get();
  $controller->clearAllCache();

  drupal_static_reset('patternbuilder_get_schemas');
  cache_clear_all('patternbuilder_schema_paths', 'cache');

  drupal_static_reset('patternbuilder_get_template_paths');

  drupal_static_reset('patternbuilder_get_pattern_types');
  cache_clear_all('patternbuilder_drupal:pattern_types', 'cache');

  drupal_static_reset('patternbuilder_components_load');

  drupal_static_reset('patternbuilder_get_resolver');
}

/**
 * Returns the machine name for a schema name.
 *
 * @param string $name
 *   A schema machine name or file name.
 *
 * @return string
 *   Machine name.
 */
function patternbuilder_clean_schema_machine_name($name) {
  if (strpos($name, '.') !== FALSE) {
    $name = basename($name, '.json');
  }

  // Replace hyphen with underscore, @see paragraphs_bundle_load().
  return strtr($name, array('-' => '_'));
}

/**
 * Resolves a file path to be used for schemas or templates.
 *
 * @param string $path
 *   The file path.
 *
 * @return string
 *   The resolved file path.
 */
function patternbuilder_resolve_file_path($path) {
  if (strpos($path, '/') === 0) {
    // Set path as root file path.
    $file_path = 'file://' . $path;
  }
  elseif (file_uri_scheme($path)) {
    // Set path as URI.
    $file_path = $path;
  }
  else {
    // Assume relative to the Drupal root.
    $file_path = 'file://' . DRUPAL_ROOT . '/' . trim($path, '/');
  }

  return $file_path;
}

/**
 * Get a list of all schema files.
 *
 * @param bool $rebuild
 *   TRUE to rebuild the schema cache.
 *
 * @return array
 *   All available schema files, keyed by the schema name.
 */
function patternbuilder_get_schemas($rebuild = FALSE) {
  $schemas = &drupal_static(__FUNCTION__);

  // Cache check.
  if (isset($schemas) && !$rebuild) {
    if (!empty($schemas)) {
      return $schemas;
    }
    elseif ($cached_schemas = cache_get('patternbuilder_schema_paths')) {
      $schemas = $cached_schemas->data;
      return $schemas;
    }
  }

  // Build cache.
  $schemas = array();
  $schema_dirs = variable_get('patternbuilder_schema_dirs', array());

  // Set to a consistent empty value.
  if (!empty($schema_dirs)) {
    // Scan directories.
    foreach ($schema_dirs as $schema_dir) {
      $files = file_scan_directory($schema_dir, '/\.json$/');
      foreach ($files as $file) {
        $machine_name = patternbuilder_clean_schema_machine_name($file->name);
        if (!isset($schemas[$machine_name])) {
          // Store resolved path.
          $schemas[$machine_name] = patternbuilder_resolve_file_path($file->uri);
        }
        else {
          // Log duplicates.
          watchdog('patternbuilder', 'Duplicate schemas found for "@name" at "@path". The first schema registered will be used until this conflict has been resolved. Active schema: "@existing"', array(
            '@name' => $machine_name,
            '@path' => $file->uri,
            '@existing' => $schemas[$machine_name],
          ), WATCHDOG_WARNING);
        }
      }
    }
  }

  // Store both non-empty and empty so not constantly rebuild for empty.
  cache_set('patternbuilder_schema_paths', $schemas);
  return $schemas;
}

/**
 * Add a schema directory.
 *
 * @param array|string $dirs
 *   An array of directories or a single directory.
 */
function patternbuilder_schema_dirs_add($dirs) {
  $stored = variable_get('patternbuilder_schema_dirs', array());

  if (!is_array($dirs)) {
    $dirs = array($dirs);
  }
  $new_dirs = array_diff($dirs, $stored);
  if ($new_dirs) {
    $stored = array_merge($stored, $new_dirs);
    variable_set('patternbuilder_schema_dirs', $stored);
    patternbuilder_get_schemas(TRUE);
  }
}

/**
 * Remove a schema directory.
 *
 * @param array|string $dirs
 *   An array of directories or a single directory.
 */
function patternbuilder_schema_dirs_remove($dirs) {
  $stored = variable_get('patternbuilder_schema_dirs', array());
  if ($stored) {
    if (!is_array($dirs)) {
      $dirs = array($dirs);
    }

    $stored = array_diff($stored, $dirs);
    variable_set('patternbuilder_schema_dirs', $stored);
    patternbuilder_get_schemas(TRUE);
  }
}

/**
 * Get a list of all template paths.
 *
 * @param bool $rebuild
 *   TRUE to rebuild the cache.
 *
 * @return array
 *   All available template paths.
 */
function patternbuilder_get_template_paths($rebuild = FALSE) {
  $cache = &drupal_static(__FUNCTION__);
  if ($rebuild || !isset($cache)) {
    $dirs = variable_get('patternbuilder_template_dirs', array());
    if (!empty($dirs)) {
      foreach ($dirs as &$dir) {
        if (strpos($dir, '/') !== 0 && !file_uri_scheme($dir)) {
          // Assume relative to the Drupal root.
          $dir = DRUPAL_ROOT . '/' . trim($dir, '/');
        }
      }
      unset($dir);
    }
    else {
      $dirs = array();
    }

    $cache = $dirs;
  }

  return $cache;
}

/**
 * Add a template directory.
 *
 * @param array|string $dirs
 *   An array of directories or a single directory.
 */
function patternbuilder_template_dirs_add($dirs) {
  $stored = variable_get('patternbuilder_template_dirs', array());

  if (!is_array($dirs)) {
    $dirs = array($dirs);
  }
  $new_dirs = array_diff($dirs, $stored);
  if ($new_dirs) {
    $stored = array_merge($stored, $new_dirs);
    variable_set('patternbuilder_template_dirs', $stored);
  }
}

/**
 * Remove a template directory.
 *
 * @param array|string $dirs
 *   An array of directories or a single directory.
 */
function patternbuilder_template_dirs_remove($dirs) {
  $stored = variable_get('patternbuilder_template_dirs', array());
  if ($stored) {
    if (!is_array($dirs)) {
      $dirs = array($dirs);
    }

    $stored = array_diff($stored, $dirs);
    variable_set('patternbuilder_template_dirs', $stored);
  }
}

/**
 * Return an instance of the patternbuilder factory class.
 *
 * @param array $twig_arguments
 *   An array of twig environment variables.
 *
 * @return DrupalPatternBuilderSchema
 *   A drupal schema factory object.
 */
function patternbuilder_get($twig_arguments = array()) {
  patternbuilder_init_libraries();
  $template_paths = patternbuilder_get_template_paths();
  $loader = new Twig_Loader_Filesystem($template_paths);
  $twig = new Twig_Environment($loader, $twig_arguments);
  $logger = new DrupalPatternBuilderLog();
  $retriever = new JsonSchema\Uri\UriRetriever();
  $resolver = new DrupalPatternBuilderRefResolver($retriever, 30);
  $configuration = new PatternBuilder\Configuration\Configuration($logger, $twig, $resolver);
  // TODO: schema object cache disabled until can effectively cache without
  // object / TWIG corruption on loading multiple of the same schema type.
  // See US83433, US70858.
  $cache_enabled = FALSE;
  return new DrupalPatternBuilderSchema($configuration, array(), $cache_enabled);
}

/**
 * Return an instance of the JSON resolver class.
 *
 * @return DrupalPatternBuilderRefResolver
 *   A reference resolver.
 */
function patternbuilder_get_resolver() {
  $resolver = &drupal_static(__FUNCTION__);
  if (!isset($resolver)) {
    patternbuilder_init_libraries();
    $retriever = new JsonSchema\Uri\UriRetriever();
    $resolver = new DrupalPatternBuilderRefResolver($retriever, 30);
  }

  return $resolver;
}

/**
 * Resolve a JSON schema object.
 *
 * @param object $schema
 *   The schema object to resolve.
 *
 * @return object
 *   The resolved schema object.
 *   Note: The $schema object is altered by reference.
 */
function patternbuilder_resolve_schema(&$schema) {
  if (isset($schema->{'$ref'})) {
    if (preg_match('@\.json$@', $schema->{'$ref'})) {
      $ref_name = basename($schema->{'$ref'}, '.json');
      if ($ref_name) {
        $schema_paths = patternbuilder_get_schemas();
        if (isset($schema_paths[$ref_name])) {
          $ref_original = $schema->{'$ref'};
          $resolver = patternbuilder_get_resolver();
          $resolver->resolve($schema, $schema_paths[$ref_name]);

          // Cleanup $ref if not removed by resolver.
          if (isset($schema->{'$ref'}) && $schema->{'$ref'} == $ref_original) {
            unset($schema->{'$ref'});
          }
        }
      }
    }
  }

  return $schema;
}

/**
 * Initializes twig and patternbuilder composer libraries.
 */
function patternbuilder_init_libraries() {
  libraries_load('patternbuilder');
}

/**
 * Returns the default pattern type used for un-claimed schemas.
 *
 * @return string
 *   The default pattern type.
 */
function patternbuilder_default_pattern_type() {
  return variable_get('patternbuilder_default_pattern_type', 'pb_default');
}

/**
 * Retrieve information for pattern types.
 *
 * @param string $pattern_type_name
 *   The pattern type machine name. If not provided, then all pattern types
 *   are returned.
 * @param bool $rebuild
 *   TRUE to rebuild the cache.
 *
 * @return array
 *   An array of information for the given pattern type. If none provided, then
 *   all pattern types are returned keyed by the pattern type machine name.
 */
function patternbuilder_get_pattern_types($pattern_type_name = NULL, $rebuild = FALSE) {
  $cache = &drupal_static(__FUNCTION__);

  if (!isset($cache) || $rebuild) {
    $cid = 'patternbuilder_drupal:pattern_types';
    if (!$rebuild && ($stored_cache = cache_get($cid))) {
      $cache = $stored_cache->data;
    }
    else {
      $cache = array();

      if ($rebuild) {
        // Rebuild module hook cache.
        module_implements('patternbuilder_pattern_types', FALSE, TRUE);
      }

      // Build pattern type cache.
      $max_weight = 0;
      foreach (module_implements('patternbuilder_pattern_types') as $module) {
        foreach (module_invoke($module, 'patternbuilder_pattern_types') as $type_name => $pattern_type_info) {
          $cache[$type_name] = $pattern_type_info;
          $cache[$type_name]['name'] = $type_name;
          $cache[$type_name]['module'] = $module;

          // Set defaults.
          $cache[$type_name] += array(
            'weight' => 0,
            'prefix' => 'pbi',
            'resolve' => FALSE,
            'field' => FALSE,
          );

          // Set default weight.
          if (!isset($cache[$type_name]['weight'])) {
            $cache[$type_name]['weight'] = 0;
          }
          elseif ($cache[$type_name]['weight'] > $max_weight) {
            $max_weight = $cache[$type_name]['weight'];
          }

          // Field based schemas must be resolved.
          if ($cache[$type_name]['field']) {
            $cache[$type_name]['resolve'] = TRUE;
          }
        }
      }

      // Set default type if not defined.
      $default_type = patternbuilder_default_pattern_type();
      if ($default_type && !isset($cache[$default_type])) {
        // This is weighted heavy to allow all other types to claim a schema
        // during import.
        $cache[$default_type] = array(
          'name' => 'pb_default',
          'label' => 'Default',
          'module' => 'patternbuilder',
          'prefix' => 'pbi',
          'resolve' => FALSE,
          'field' => FALSE,
          'weight' => $max_weight + 100,
        );
      }

      drupal_alter('patternbuilder_pattern_types', $cache);
      uasort($cache, 'drupal_sort_weight');
      cache_set($cid, $cache);
    }
  }

  // Single type return.
  if (isset($pattern_type_name)) {
    return isset($cache[$pattern_type_name]) ? $cache[$pattern_type_name] : array();
  }

  // Return all types.
  return $cache;
}

/**
 * Returns a list of pattern type labels.
 *
 * @return array
 *   An array keyed by pattern type machine name with labels as values.
 */
function patternbuilder_pattern_types_labels() {
  $labels = array();

  $types = patternbuilder_get_pattern_types();
  if ($types) {
    foreach ($types as $name => $info) {
      $label = isset($info['label']) ? $info['label'] : $name;
      $labels[$name] = $label;
    }
  }

  return $labels;
}

/**
 * Returns an option list suitable for an HTML element.
 */
function patternbuilder_pattern_types_options_list() {
  $options = array();
  $labels = patternbuilder_pattern_types_labels();
  if ($labels) {
    $options = array_map('check_plain', $labels);
  }

  return $options;
}

/**
 * Returns a list of paragraph bundle labels.
 *
 * @return array
 *   An array keyed by bundle machine name with labels as values.
 */
function patternbuilder_paragraph_bundle_labels() {
  $labels = array();
  $bundles = paragraphs_bundle_load();

  foreach ($bundles as $name => $bundle) {
    $labels[$name] = !empty($bundle->name) ? $bundle->name : $name;
  }
  return $labels;
}

/**
 * Loads all component IDs from memory.
 *
 * @return array
 *   All components by machine name => id
 */
function _patternbuilder_component_ids_load() {
  return db_select('patternbuilder_components', 'c')
    ->fields('c', array('machine_name', 'id'))
    ->orderBy('c.id', 'ASC')
    ->execute()
    ->fetchAllKeyed();
}

/**
 * Load stored pattern components.
 *
 * @param string|null $machine_name
 *   The component machine name or NULL to load all.
 * @param bool $rebuild
 *   TRUE to rebuild the cache.
 *
 * @return array|object|null
 *   The component object if $machine_name is provided, else all components
 *   keyed by machine name.
 */
function patternbuilder_components_load($machine_name = NULL, $rebuild = FALSE) {
  $cache = &drupal_static(__FUNCTION__);

  if ($rebuild || !isset($cache)) {
    $cache = array();
    $records = db_select('patternbuilder_components', 'c')
      ->fields('c')
      ->orderBy('c.id', 'ASC')
      ->execute()
      ->fetchAllAssoc('machine_name');

    if ($records) {
      $cache = $records;
    }
  }

  if (!empty($machine_name)) {
    return isset($cache[$machine_name]) ? $cache[$machine_name] : NULL;
  }

  return $cache;
}

/**
 * Returns the pattern component for a given bundle.
 *
 * @param string $bundle_name
 *   The bundle name.
 *
 * @return object|null
 *   The pattern component object corresponding to the bundle.
 */
function patternbuilder_get_bundle_component($bundle_name) {
  $components = patternbuilder_components_load();
  foreach ($components as $machine_name => $component) {
    if (!empty($component->bundle_name) && $component->bundle_name == $bundle_name) {
      return $component;
    }
  }
}

/**
 * Returns the pattern component for all bundles.
 *
 * @return array
 *   An array of pattern component objects keyed by bundle name.
 */
function patternbuilder_get_bundle_component_map() {
  $return = array();
  $components = patternbuilder_components_load();
  foreach ($components as $machine_name => $component) {
    if (!empty($component->bundle_name)) {
      $return[$component->bundle_name] = $component;
    }
  }

  return $return;
}

/**
 * Returns a map of pattern type to bundles.
 *
 * @param string|null $pattern_type_name
 *   The component pattern type or NULL to load all pattern types.
 * @param bool $rebuild
 *   TRUE to rebuild the cache.
 *
 * @return array
 *   An array with keys of pattern type and values of an array of bundle names
 *   keyed by machine name.
 */
function patternbuilder_components_get_pattern_type_bundles($pattern_type_name = NULL, $rebuild = FALSE) {
  $return = array();
  $components = patternbuilder_components_load(NULL, $rebuild);

  if (!empty($pattern_type_name)) {
    foreach ($components as $machine_name => $component) {
      if (!empty($component->bundle_name) && !empty($component->pattern_type) && $component->pattern_type == $pattern_type_name) {
        $return[$machine_name] = $component->bundle_name;
      }
    }

    asort($return);
  }
  else {
    foreach ($components as $machine_name => $component) {
      if (!empty($component->bundle_name)) {
        $pattern_type_key = !empty($component->pattern_type) ? $component->pattern_type : '';
        $return[$pattern_type_key][$machine_name] = $component->bundle_name;
      }
    }

    foreach ($return as $pattern_type_key => &$pattern_type_components) {
      asort($pattern_type_components);
    }
    unset($pattern_type_components);
  }

  return $return;
}

/**
 * Determine if the component is resolved.
 *
 * @param object|string $component
 *   The component object or machine name.
 *
 * @return bool
 *   TRUE if the component is a resolved schema.
 */
function patternbuilder_component_is_resolved($component) {
  if (is_string($component)) {
    $component = patternbuilder_components_load($component);
  }

  if (isset($component->pattern_type) && $component->pattern_type) {
    $type_info = patternbuilder_get_pattern_types($component->pattern_type);
    return !empty($type_info['resolve']);
  }

  return FALSE;
}

/**
 * Determine if the component is a field based schema.
 *
 * @param object|string $component
 *   The component object or machine name.
 *
 * @return bool
 *   TRUE if the component is a field.
 */
function patternbuilder_component_is_field($component) {
  if (is_string($component)) {
    $component = patternbuilder_components_load($component);
  }

  if (isset($component->pattern_type) && $component->pattern_type) {
    $type_info = patternbuilder_get_pattern_types($component->pattern_type);
    return !empty($type_info['field']);
  }

  return FALSE;
}

/**
 * Returns the pattern component for a given field name.
 *
 * @param string $field_name
 *   The field name.
 *
 * @return object|null
 *   The pattern component object corresponding to the bundle.
 */
function patternbuilder_get_field_component($field_name) {
  $components = patternbuilder_components_load();
  foreach ($components as $machine_name => $component) {
    if (!empty($component->field_name) && $component->field_name == $field_name) {
      return $component;
    }
  }
}

/**
 * Adds a unique machine name to the component table.
 *
 * @param string $machine_name
 *   The pattern machine name.
 * @param string $pattern_type_name
 *   The pattern type name.
 * @param string $bundle_name
 *   The entity bundle machine name.
 * @param string $field_name
 *   The field name.
 *
 * @return object
 *   The fully loaded saved component object.
 *
 * @throws \Exception
 *   General error.
 */
function patternbuilder_component_save($machine_name, $pattern_type_name = '', $bundle_name = NULL, $field_name = NULL) {
  if (empty($pattern_type_name)) {
    $pattern_type_name = patternbuilder_default_pattern_type();
  }

  if (empty($bundle_name)) {
    $bundle_name = NULL;
  }

  if (empty($field_name)) {
    $field_name = NULL;
  }

  db_merge('patternbuilder_components')
    ->key(array('machine_name' => $machine_name))
    ->fields(array(
      'machine_name' => $machine_name,
      'pattern_type' => $pattern_type_name,
      'bundle_name' => $bundle_name,
      'field_name' => $field_name,
    ))
    ->execute();

  // Rebuild load cache and return the component.
  return patternbuilder_components_load($machine_name, TRUE);
}

/**
 * Returns custom field instance settings for patternbuilder.
 *
 * @param array $instance
 *   An array of field instance info.
 * @param bool $only_stored
 *   TRUE to only return stored values with no defaults or processing.
 *
 * @return array
 *   An array of patternbuilder instance settings.
 */
function _patternbuilder_field_instance_settings(array $instance, $only_stored = FALSE) {
  $defaults = array(
    'hidden' => FALSE,
    'readonly' => FALSE,
    'property_name' => NULL,
    'parent_property_names' => NULL,
    'property_map' => NULL,
    'real_property_name' => NULL,
    'parent_property_names_array' => array(),
    'property_map_array' => array(),
  );

  $settings = array();
  if (!empty($instance['settings']['patternbuilder'])) {
    $settings = $instance['settings']['patternbuilder'];
    if (!$only_stored) {
      $settings += $defaults;
    }
  }
  elseif (!$only_stored) {
    $settings = $defaults;
  }

  // Set property_name based on field name if empty.
  if (!$only_stored && empty($settings['property_name']) && isset($instance['field_name'])) {
    $parts = explode('_', $instance['field_name']);
    if ($parts) {
      $settings['property_name'] = array_pop($parts);
    }
  }

  // Resolve real property name.
  if (isset($settings['property_name'])) {
    $settings['real_property_name'] = patternbuilder_get_property_real_name($settings['property_name']);
  }

  // Resolve parents.
  if (!empty($settings['parent_property_names'])) {
    $settings['parent_property_names_array'] = explode(PATTERNBUILDER_PROPERTY_DELIMITER, $settings['parent_property_names']);
  }

  // Property map.
  if (!empty($settings['property_map'])) {
    $settings['property_map_array'] = patternbuilder_parse_field_property_map($settings['property_map']);
  }

  return $settings;
}

/**
 * Extracts the real name for a property name.
 *
 * @param string $name
 *   The property name.
 *
 * @return string
 *   The real property name.
 */
function patternbuilder_get_property_real_name($name) {
  if (isset($name) && strpos($name, PATTERNBUILDER_PROPERTY_DELIMITER) !== FALSE) {
    $chain = explode(PATTERNBUILDER_PROPERTY_DELIMITER, $name);
    // The real name is the last part.
    return array_pop($chain);
  }

  return $name;
}

/**
 * Determine if the property is a tuple item.
 *
 * Tuple item properties are generated names which are not defined in the
 * schema.
 *
 * @param string $property_name
 *   The raw property name.
 *
 * @return bool
 *   TRUE if the property is a tuple item.
 */
function patternbuilder_property_is_tuple_item($property_name) {
  return strpos($property_name, PATTERNBUILDER_PROPERTY_PREFIX_TUPLE_ITEM . PATTERNBUILDER_PROPERTY_DELIMITER) === 0;
}

/**
 * Parses a property map string to an array.
 *
 * @param string $map_string
 *   The property map combined string.
 *
 * @return array
 *   The property map parsed array.
 */
function patternbuilder_parse_field_property_map($map_string) {
  $map = array();
  $items = explode(PATTERNBUILDER_PROPERTY_MAP_ITEM_DELIMITER, $map_string);
  if ($items) {
    foreach ($items as $item) {
      list($key, $value) = explode(PATTERNBUILDER_PROPERTY_MAP_VALUE_DELIMITER, $item);
      if (isset($key) && isset($value)) {
        $map[trim($key)] = trim($value);
      }
    }
  }

  return $map;
}

/**
 * Creates a property map string from a map array.
 *
 * @param array $map
 *   The property map array.
 *
 * @return array
 *   The property map parsed array.
 */
function patternbuilder_join_field_property_map(array $map) {
  $items = array();
  foreach ($map as $key => $value) {
    $items[] = trim($key) . PATTERNBUILDER_PROPERTY_MAP_VALUE_DELIMITER . trim($value);
  }

  return $items ? implode(PATTERNBUILDER_PROPERTY_MAP_ITEM_DELIMITER, $items) : '';
}

/**
 * Determines if a field instance has patternbuilder settings.
 *
 * @param array $instance
 *   An array of field instance info.
 *
 * @return bool
 *   TRUE if the field instance has patternbuilder settings.
 */
function _patternbuilder_field_instance_has_settings(array $instance) {
  return isset($instance['settings']['patternbuilder']) ||
     ($instance['entity_type'] === 'paragraphs_item' &&
      patternbuilder_get_bundle_component($instance['bundle']));
}

/**
 * Returns all field instances that are mapped to a property.
 *
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The entity bundle name.
 *
 * @return array
 *   An array of field instances keyed by field name.
 */
function _patternbuilder_field_info_instances($entity_type, $bundle_name) {
  $property_instances = array();
  $instances = field_info_instances($entity_type, $bundle_name);

  foreach ($instances as $field_name => $instance) {
    $settings = _patternbuilder_field_instance_settings($instance, TRUE);
    if ($settings && isset($settings['real_property_name'])) {
      // Set resolved values on instance array to reduce calls to resolved.
      $instance['settings']['patternbuilder'] = $settings;
      $property_instances[$field_name] = $instance;
    }
  }

  return $property_instances;
}

/**
 * Finds the field instance for given property in a given component.
 *
 * Only a single bundle level is supported. This does not attempt to chain
 * into fields that are field collections or paragraphs.
 *
 * @param string $component_machine_name
 *   The machine name of the component schema.
 * @param string|array $property_names
 *   The property name or an array of property names representing the
 *   hierarchical property structure with the last item being the desired
 *   property name.
 *
 * @return array|null
 *   The field instance info array if found.
 */
function patternbuilder_field_info_property_instance($component_machine_name, $property_names) {
  if (is_string($property_names)) {
    $property_names = array($property_names);
  }
  elseif (!is_array($property_names)) {
    return NULL;
  }

  $component = patternbuilder_components_load($component_machine_name);
  if (empty($component->bundle_name)) {
    return NULL;
  }

  $entity_type = 'paragraphs_item';
  $bundle_name = $component->bundle_name;
  $instances = _patternbuilder_field_info_instances($entity_type, $bundle_name);
  if (empty($instances)) {
    return NULL;
  }

  // Note: only a single bundle level is supported. This does not attempt to
  // chain into fields that are field collections or paragraphs.
  $property_name = array_pop($property_names);
  $parent_names = $property_names ? implode(PATTERNBUILDER_PROPERTY_DELIMITER, $property_names) : '';
  foreach ($instances as $field_name => $instance) {
    $settings = _patternbuilder_field_instance_settings($instance, TRUE);
    if ($settings['real_property_name'] == $property_name) {
      if (!$parent_names || $parent_names == $settings['parent_property_names']) {
        return $instance;
      }
    }
  }
}

/**
 * Determines if an entity is considered to be a tuple.
 *
 * If there is at least 1 non-tuple item property field then none are returned.
 *
 * @param string $entity_type
 *   The entity type.
 * @param object $entity
 *   The entity object.
 *
 * @return bool
 *   TRUE if the entity is a tuple.
 */
function _patternbuilder_entity_is_tuple($entity_type, $entity) {
  list($entity_id, $entity_revision_id, $entity_bundle) = entity_extract_ids($entity_type, $entity);
  return isset($entity_bundle) && _patternbuilder_field_info_instance_tuple_items($entity_type, $entity_bundle);
}

/**
 * Returns all field instances that are mapped to a tuple item property.
 *
 * If there is at least 1 non-tuple item property field then none are returned.
 *
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The entity bundle name.
 *
 * @return array
 *   An array of tuple item field instances keyed by field names.
 */
function _patternbuilder_field_info_instance_tuple_items($entity_type, $bundle_name) {
  $filtered_instances = array();
  $instances = field_info_instances($entity_type, $bundle_name);

  foreach ($instances as $field_name => $instance) {
    if (isset($instance['settings']['patternbuilder']['property_name'])) {
      $raw_property_name = $instance['settings']['patternbuilder']['property_name'];

      // Exit if there is at least 1 non-tuple item.
      if (!patternbuilder_property_is_tuple_item($raw_property_name)) {
        return array();
      }

      $field_info = field_info_field($field_name);

      // Tuple items must be an entity to store the schema name to load.
      if ($field_info['type'] != 'field_collection' && $field_info['type'] != 'paragraphs') {
        return array();
      }

      $filtered_instances[$field_name] = $instance;
    }
  }

  return $filtered_instances;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Implemented for field_ui_field_edit_form.
 */
function patternbuilder_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  $instance = $form['#instance'];

  // If pb settings imported OR is a pattern paragraphs item.
  if (_patternbuilder_field_instance_has_settings($instance)) {
    // Fieldset for Pattern Builder settings on this field instance.
    $form['instance']['settings']['patternbuilder'] = array(
      '#type' => 'fieldset',
      '#title' => t('Pattern Builder'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );

    $settings = _patternbuilder_field_instance_settings($instance);

    $form['instance']['settings']['patternbuilder']['property_name'] = array(
      '#type' => 'textfield',
      '#title' => t('Property name'),
      '#description' => t('The machine name of the pattern schema property that corresponds to this field.'),
      '#default_value' => $settings['property_name'],
    );

    $form['instance']['settings']['patternbuilder']['parent_property_names'] = array(
      '#type' => 'textfield',
      '#title' => t('Parent property names'),
      '#description' => t('The parent machine names of the pattern schema property that corresponds to this field. Parents are separated by "@delim". Example: "group1@delimgroup2"', array(
        '@delim' => PATTERNBUILDER_PROPERTY_DELIMITER,
      )),
      '#default_value' => $settings['parent_property_names'],
    );

    $form['instance']['settings']['patternbuilder']['property_map'] = array(
      '#type' => 'textfield',
      '#title' => t('Property map'),
      '#description' => t('The mapping of Drupal field properties to schema properties. Example: "@map"', array(
        '@map' => patternbuilder_join_field_property_map(array(
          'url' => 'src',
          'title' => 'text',
        )),
      )),
      '#default_value' => $settings['property_map'],
    );

    $form['instance']['settings']['patternbuilder']['hidden'] = array(
      '#type' => 'checkbox',
      '#title' => t('Hidden on the edit form'),
      '#default_value' => $settings['hidden'],
    );

    $form['instance']['settings']['patternbuilder']['readonly'] = array(
      '#type' => 'checkbox',
      '#title' => t('Read-only on the edit form'),
      '#default_value' => $settings['readonly'],
    );
  }
}

/**
 * Implements hook_field_attach_form().
 */
function patternbuilder_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Limit scope to only patternbuilder maintained entity types.
  if ($entity_type !== 'paragraphs_item' && $entity_type !== 'field_collection_item') {
    return;
  }

  list($entity_id, $entity_vid, $bundle_name) = entity_extract_ids($entity_type, $entity);

  // Exit if no bundle.
  if (empty($bundle_name)) {
    return;
  }

  // Alter the field elements.
  $field_instances = field_info_instances($entity_type, $bundle_name);
  foreach ($field_instances as $field_name => $field_instance) {
    if (!isset($form[$field_name])) {
      continue;
    }

    $instance_settings = _patternbuilder_field_instance_settings($field_instance);
    if (empty($instance_settings)) {
      continue;
    }

    // Determine the field flags.
    $is_required = isset($field_instance['required']) && !empty($field_instance['required']);
    $is_readonly = !empty($instance_settings['readonly']);
    $is_hidden = !empty($instance_settings['hidden']);

    // Hide or disable fields only if they are not required or have values.
    // Note: This is neeed so that a required field is not disabled or
    // hidden with an empty value causing form validations errors that cannot
    // be fixed by the user.
    if ($is_readonly || $is_hidden) {
      $can_hide = !$is_required;
      if (!$can_hide) {
        $field_language = $form[$field_name]['#language'];
        $on_value = isset($form[$field_name][$field_language]['#on_value']) ? $form[$field_name][$field_language]['#on_value'] : NULL;
        $value_key = NULL;
        if (isset($form[$field_name][$field_language]['#value_key'])) {
          $value_key = $form[$field_name][$field_language]['#value_key'];
        }
        elseif (!empty($form[$field_name][$field_language][0]['#columns'])) {
          $value_key = reset($form[$field_name][$field_language][0]['#columns']);
        }

        // Inspect the form array if there are no values on the entity.
        if (isset($form[$field_name][$field_language]['#default_value'])) {
          if ((isset($on_value) && $form[$field_name][$field_language]['#default_value'] == $on_value) || $form[$field_name][$field_language]['#default_value'] !== '') {
            $can_hide = TRUE;
          }
        }
        elseif (isset($form[$field_name][$field_language][0])) {
          foreach (element_children($form[$field_name][$field_language]) as $delta) {
            if (is_numeric($delta)) {
              $value_element = isset($form[$field_name][$field_language][$delta][$value_key]) ? $form[$field_name][$field_language][$delta][$value_key] : $form[$field_name][$field_language][$delta];
              if (isset($value_element['#default_value'])) {
                if ((isset($on_value) && $value_element['#default_value'] == $on_value) || $value_element['#default_value'] !== '') {
                  $can_hide = TRUE;
                  break;
                }
              }
            }
          }
        }
      }

      if ($can_hide) {
        // Read-only properties.
        if ($is_readonly) {
          $form[$field_name]['#disabled'] = TRUE;
        }

        // Hidden properties.
        if ($is_hidden) {
          $form[$field_name]['#access'] = FALSE;
        }
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function patternbuilder_field_widget_info() {
  return array(
    'patternbuilder_paragraphs_embed' => array(
      'label' => t('Embedded Patterns'),
      'field types' => array('paragraphs'),
      'settings' => array(
        'allowed_pattern_types' => array(),
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function patternbuilder_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'] + field_info_widget_settings($widget['type']);
  $form = NULL;

  if ($widget['type'] == 'patternbuilder_paragraphs_embed') {
    $form = array();
    $pattern_type_options = patternbuilder_pattern_types_options_list();

    // Limit the list to patterns mapped to bundles.
    $pattern_type_bundles = patternbuilder_components_get_pattern_type_bundles();
    $pattern_type_options = array_intersect_key($pattern_type_options, $pattern_type_bundles);

    $form['allowed_pattern_types'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Allowed Pattern Types'),
      '#description' => t('If no pattern type is selected, then all pattern types will be available.'),
      '#default_value' => $settings['allowed_pattern_types'],
      '#options' => $pattern_type_options,
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function patternbuilder_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $elements = array();

  if ($instance['widget']['type'] == 'patternbuilder_paragraphs_embed') {
    $elements = patternbuilder_paragraphs_field_multiple_value_form($field, $instance, $langcode, $items, $form, $form_state, $delta, $element);
  }

  return $elements;
}

/**
 * Implements hook_field_widget_form_build().
 *
 * The function paragraphs_field_multiple_value_form() calls this function
 * for the widget module.
 *
 * @see paragraphs_field_multiple_value_form()
 * @see paragraphs_field_widget_form_build()
 */
function patternbuilder_field_widget_form_build(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  module_load_include('inc', 'paragraphs', 'paragraphs.field_widget');
  $element = paragraphs_field_widget_form_build($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
  return $element;
}

/**
 * Special handling to create elements for multiple paragraph pattern embeds.
 *
 * @see paragraphs_field_multiple_value_form()
 */
function patternbuilder_paragraphs_field_multiple_value_form($field, $instance, $langcode, $items, &$form, &$form_state, $delta, $element) {
  $widget = $instance['widget'];
  $settings = $widget['settings'] + field_info_widget_settings($widget['type']);

  // Set allowed bundles to the allowed patterns.
  $available_bundles = paragraphs_bundle_load();
  $available_bundle_names = array_keys($available_bundles);

  // Build instance allowed bundles.
  $instance_allowed_bundles = array();
  if (!empty($instance['settings']['allowed_bundles'])) {
    foreach ($instance['settings']['allowed_bundles'] as $bundle_setting_key => $bundle_setting_value) {
      if ($bundle_setting_key === $bundle_setting_value && isset($available_bundles[$bundle_setting_key])) {
        $instance_allowed_bundles[$bundle_setting_key] = $bundle_setting_key;
      }
    }
  }

  if (empty($instance_allowed_bundles)) {
    $instance_allowed_bundles = $available_bundle_names;
  }

  // Pattern type allowed bundles.
  $available_pattern_type_bundles = patternbuilder_components_get_pattern_type_bundles();

  $pattern_types_allowed = array();
  if (isset($settings['allowed_pattern_types'])) {
    $pattern_types_allowed = array_keys(array_filter($settings['allowed_pattern_types']));
  }

  if (empty($pattern_types_allowed)) {
    $pattern_types_allowed = array_keys($available_pattern_type_bundles);
  }

  $pattern_allowed_bundles = array();
  foreach ($pattern_types_allowed as $allowed_pattern_type) {
    if (isset($available_pattern_type_bundles[$allowed_pattern_type])) {
      $pattern_allowed_bundles += $available_pattern_type_bundles[$allowed_pattern_type];
    }
  }

  // Build allowed bundles.
  $allowed_bundles = array_intersect($pattern_allowed_bundles, $instance_allowed_bundles, $available_bundle_names);

  // Override instance settings.
  $instance['settings']['allowed_bundles'] = array_combine($allowed_bundles, $allowed_bundles);

  // Build form elements.
  module_load_include('inc', 'paragraphs', 'paragraphs.field_widget');
  $elements = paragraphs_field_multiple_value_form($field, $instance, $langcode, $items, $form, $form_state, $delta, $element);

  return $elements;
}

/**
 * Implements hook_theme().
 */
function patternbuilder_theme() {
  $module_path = drupal_get_path('module', 'patternbuilder');
  return array(
    'patternbuilder_items' => array(
      'render element' => 'element',
      'template' => 'patternbuilder-items',
      'path' => $module_path . '/theme',
      'file' => 'theme.inc',
    ),
    'patternbuilder_item' => array(
      'render element' => 'elements',
      'template' => 'patternbuilder-item',
      'path' => $module_path . '/theme',
      'file' => 'theme.inc',
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function patternbuilder_field_formatter_info() {
  return array(
    'patternbuilder_view' => array(
      'label' => t('Patternbuilder rendered items'),
      'field types' => array('paragraphs'),
      'settings' => array(
        'view_mode' => 'full',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function patternbuilder_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $elements = array();

  if ($display['type'] == 'patternbuilder_view') {
    $entity_info = entity_get_info('paragraphs_item');
    $view_mode_options = array();
    foreach ($entity_info['view modes'] as $view_mode => $view_mode_info) {
      $view_mode_options[$view_mode] = isset($view_mode_info['label']) ? $view_mode_info['label'] : $view_mode;
      $view_mode_options[$view_mode] = check_plain($view_mode_options[$view_mode]);
    }

    $elements['view_mode'] = array(
      '#type' => 'select',
      '#title' => t('View mode'),
      '#options' => $view_mode_options,
      '#default_value' => $settings['view_mode'],
      '#description' => t('The selected view mode is used to render the paragraph item fields.'),
    );
  }

  return $elements;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function patternbuilder_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $output = array();

  if ($display['type'] == 'patternbuilder_view') {
    $entity_info = entity_get_info('paragraphs_item');
    if (isset($entity_info['view modes'][$settings['view_mode']])) {
      $view_mode_label = $settings['view_mode'];
      if (!empty($entity_info['view modes'][$settings['view_mode']]['label'])) {
        $view_mode_label = $entity_info['view modes'][$settings['view_mode']]['label'];
      }

      $output[] = t('View mode: @mode', array(
        '@mode' => $view_mode_label,
      ));
    }
    else {
      $output[] = ' ';
    }
  }

  return implode('<br />', $output);
}

/**
 * Implements hook_field_formatter_prepare_view().
 */
function patternbuilder_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  // @todo: Preload Twig renderers similar to a node reference field formatter?
}

/**
 * Implements hook_field_formatter_view().
 */
function patternbuilder_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'] + field_info_formatter_settings($display['type']);

  if (empty($items)) {
    return $element;
  }

  switch ($display['type']) {
    case 'patternbuilder_view':
      $paragraph_info = entity_get_info('paragraphs_item');

      // @todo: Recursion check like entity reference field.

      // Set the items theme.
      $element['#theme_wrappers'] = array();
      $element['#theme'] = array('patternbuilder_items');

      // Get the view mode.
      $display_view_mode = 'full';
      if (!empty($settings['view_mode']) && isset($paragraph_info['view modes'][$settings['view_mode']])) {
        $display_view_mode = $settings['view_mode'];
      }

      // Process items.
      foreach ($items as $delta => $item) {
        if ($paragraph = paragraphs_field_get_entity($item)) {
          $paragraph->setHostEntity($entity_type, $entity, $langcode);
          if (entity_access('view', 'paragraphs_item', $paragraph)) {
            $element[$delta] = array(
              '#theme' => 'patternbuilder_item',
              '#entity_type' => 'paragraphs_item',
              '#entity' => $paragraph,
              '#language' => $langcode,
              '#view_mode' => $display_view_mode,
            );
          }
        }
      }

      break;
  }

  return $element;
}
